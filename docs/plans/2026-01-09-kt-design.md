# kt - Git-backed Issue Tracker Design

Go reimplementation of [ticket](https://github.com/wedow/ticket), a minimal git-backed issue tracker for AI agents.

## Overview

`kt` stores tickets as markdown files with YAML frontmatter in `.kticket/`. Designed for AI agents to easily search and manipulate without dumping large JSON blobs into context windows.

**Key features:**
- Partial ID matching (`a1b2` matches `kt-a1b2`)
- Dependency tracking with blocking/blocked queries
- Symmetric linking between related tickets
- Test validation gate before closing
- JSON output for scripting (auto-detected when piped)

## Project Structure

```
kt/
├── cmd/kt/
│   └── main.go                  # Entry point
├── internal/
│   ├── ticket/
│   │   ├── ticket.go            # Ticket struct, parse/write
│   │   └── ticket_test.go
│   ├── store/
│   │   ├── store.go             # Filesystem ops (.kticket/)
│   │   ├── id.go                # ID generation + resolution
│   │   └── store_test.go
│   └── cmd/
│       ├── root.go              # Cobra root, --json flag, TTY detection
│       ├── create.go
│       ├── status.go            # start/close/reopen/status/pass
│       ├── dep.go               # dep add/rm/tree
│       ├── link.go              # link add/rm
│       ├── list.go              # ls/ready/blocked/closed/stats
│       ├── show.go              # show/edit/add-note
│       ├── query.go
│       └── cmd_test.go          # Integration tests
├── testdata/                    # Autogold golden files
├── go.mod
├── go.sum
└── README.md
```

## Dependencies

| Package | Purpose |
|---------|---------|
| `github.com/spf13/cobra` | CLI framework |
| `github.com/goccy/go-yaml` | YAML parsing (3-5x faster than yaml.v3) |
| `golang.org/x/term` | TTY detection for output mode |
| `github.com/stretchr/testify` | Test assertions (dev) |
| `github.com/hexops/autogold/v2` | Golden file testing (dev) |

## Core Types

### Ticket

```go
type Status string

const (
    StatusOpen       Status = "open"
    StatusInProgress Status = "in_progress"
    StatusClosed     Status = "closed"
)

type Type string

const (
    TypeBug     Type = "bug"
    TypeFeature Type = "feature"
    TypeTask    Type = "task"
    TypeEpic    Type = "epic"
    TypeChore   Type = "chore"
)

type Ticket struct {
    // Frontmatter fields (YAML)
    ID          string   `yaml:"id"`
    Status      Status   `yaml:"status"`
    Deps        []string `yaml:"deps"`
    Links       []string `yaml:"links"`
    Created     string   `yaml:"created"`
    Type        Type     `yaml:"type"`
    Priority    int      `yaml:"priority"`
    Assignee    string   `yaml:"assignee,omitempty"`
    ExternalRef string   `yaml:"external-ref,omitempty"`
    Parent      string   `yaml:"parent,omitempty"`
    TestsPassed bool     `yaml:"tests_passed"`

    // Parsed from markdown body
    Title              string `yaml:"-"`
    Description        string `yaml:"-"`
    Design             string `yaml:"-"`
    AcceptanceCriteria string `yaml:"-"`
    Tests              string `yaml:"-"`
    Notes              string `yaml:"-"`
}
```

### Storage Format

File: `.kticket/<id>.md`

```markdown
---
id: kt-a1b2
status: in_progress
deps: [kt-c3d4]
links: []
created: 2026-01-09T10:30:00Z
type: feature
priority: 1
assignee: kostya
tests_passed: false
---
# Add user authentication

Implement basic auth flow with session tokens.

## Design

Use JWT tokens with 24h expiry.

## Acceptance Criteria

- Users can log in with email/password
- Session persists across browser refresh

## Tests

- TestLoginSuccess
- TestLoginInvalidPassword
- TestLoginRateLimit

## Notes

**2026-01-09T14:00:00Z**

Decided to use bcrypt for password hashing.
```

### Close Validation

```go
func (t *Ticket) CanClose() error {
    if t.Tests != "" && !t.TestsPassed {
        return fmt.Errorf("cannot close %s: tests not passed (run 'kt pass %s' first)", t.ID, t.ID)
    }
    return nil
}
```

- No `## Tests` section → can close freely
- Has `## Tests` + `tests_passed: false` → blocked
- Has `## Tests` + `tests_passed: true` → can close

## Store

```go
type Store struct {
    Dir string // defaults to ".kticket", override with KTICKET_DIR env var
}

func New(dir string) *Store
func (s *Store) EnsureDir() error
func (s *Store) List() ([]*ticket.Ticket, error)
func (s *Store) Get(id string) (*ticket.Ticket, error)
func (s *Store) Resolve(partial string) (*ticket.Ticket, error)
func (s *Store) Save(t *ticket.Ticket) error
func (s *Store) Delete(id string) error
```

### ID Generation

```go
func GenerateID() (string, error) {
    cwd, _ := os.Getwd()
    dir := filepath.Base(cwd)

    // Extract prefix: "my-project" → "mp", "kticket" → "k"
    prefix := extractPrefix(dir)

    // 4-char hash from PID + timestamp
    data := fmt.Sprintf("%d%d", os.Getpid(), time.Now().UnixNano())
    hash := fmt.Sprintf("%x", sha256.Sum256([]byte(data)))[:4]

    return fmt.Sprintf("%s-%s", prefix, hash), nil
}

func extractPrefix(name string) string {
    // Split on - or _
    parts := regexp.MustCompile(`[-_]`).Split(name, -1)
    if len(parts) == 1 {
        // No separators: use first 1-3 chars
        if len(name) > 3 {
            return name[:3]
        }
        return name
    }
    // First letter of each part
    var prefix string
    for _, p := range parts {
        if len(p) > 0 {
            prefix += string(p[0])
        }
    }
    return prefix
}
```

### Partial ID Resolution

```go
func (s *Store) Resolve(partial string) (*ticket.Ticket, error) {
    // Try exact match first
    if t, err := s.Get(partial); err == nil {
        return t, nil
    }

    // Find substring matches
    matches, _ := filepath.Glob(filepath.Join(s.Dir, "*"+partial+"*.md"))

    switch len(matches) {
    case 0:
        return nil, fmt.Errorf("ticket %q not found", partial)
    case 1:
        return s.parseFile(matches[0])
    default:
        return nil, fmt.Errorf("ambiguous ID %q matches multiple tickets", partial)
    }
}
```

## Commands

### Global Flags

```
kt [--json] <command>
```

**Output mode detection:**
```go
func getOutputMode() string {
    if !term.IsTerminal(int(os.Stdout.Fd())) {
        return "json"  // Piped → JSON
    }
    if jsonFlag {
        return "json"  // Explicit flag
    }
    return "text"
}
```

### Command Reference

```
kt create [title] [flags]       Create ticket, prints ID
  -d, --description             Description text
  --design                      Design notes
  --acceptance                  Acceptance criteria
  --tests                       Test requirements
  -t, --type                    Type (bug|feature|task|epic|chore) [default: task]
  -p, --priority                Priority 0-4, 0=highest [default: 2]
  -a, --assignee                Assignee [default: git user.name]
  --external-ref                External reference (e.g., gh-123)
  --parent                      Parent ticket ID

kt start <id>...                Set status to in_progress
kt close <id>...                Set status to closed (validates tests_passed)
kt reopen <id>...               Set status to open
kt status <id> <status>         Set arbitrary status
kt pass <id>...                 Set tests_passed = true

kt dep add <id> <dep-id>        Add dependency (id depends on dep-id)
kt dep rm <id> <dep-id>         Remove dependency
kt dep tree [--full] <id>       Show dependency tree (--full disables dedup)

kt link add <id> <id> [id...]   Link tickets together (symmetric)
kt link rm <id> <target-id>     Remove link between tickets

kt ls [--status=X]              List tickets
kt ready                        List open/in_progress with deps resolved
kt blocked                      List open/in_progress with unresolved deps
kt closed [--limit=N]           List recently closed (default 20, by mtime)
kt stats                        Show ticket counts by status

kt show <id>...                 Display ticket(s)
kt edit <id>                    Open ticket in $EDITOR
kt add-note <id> [text]         Append timestamped note (or pipe stdin)

kt query [jq-filter]            Output tickets as JSON, optionally filtered
```

### Output Examples

**Text mode (terminal):**
```
$ kt ls
kt-a1b2  [open]         Add auth
kt-c3d4  [in_progress]  Fix login bug

$ kt stats
open:         12
in_progress:   3
closed:       47
──────────────
total:        62

$ kt dep tree kt-a1b2
kt-a1b2 [open] Add auth
├── kt-c3d4 [closed] Setup database
└── kt-e5f6 [in_progress] Create user model
    └── kt-g7h8 [closed] Define schema
```

**JSON mode (piped or --json):**
```
$ kt ls | jq '.[0]'
{
  "id": "kt-a1b2",
  "status": "open",
  "title": "Add auth",
  ...
}

$ kt --json stats
{"open":12,"in_progress":3,"closed":47,"total":62}

$ kt --json close kt-a1b2 kt-c3d4
{"updated":["kt-a1b2"],"errors":[{"id":"kt-c3d4","error":"tests not passed"}]}
```

## Testing Strategy

### Unit Tests

| File | Tests |
|------|-------|
| `ticket_test.go` | ParseFile, WriteFile, CanClose, roundtrip |
| `store_test.go` | GenerateID, extractPrefix, Resolve (exact/partial/ambiguous/notfound), List |

### Integration Tests

Using `autogold` for golden file management:

```go
func TestLsOutput(t *testing.T) {
    s := setupTestStore(t)
    createTicket(s, "Task A", StatusOpen)
    createTicket(s, "Task B", StatusClosed)

    out := runCmd(t, "ls")
    autogold.ExpectFile(t, out)
}

func TestCloseBlockedByTests(t *testing.T) {
    s := setupTestStore(t)
    id := createTicketWithTests(s, "Feature X")

    err := runCmdErr(t, "close", id)
    assert.ErrorContains(t, err, "tests not passed")

    runCmd(t, "pass", id)
    runCmd(t, "close", id)  // succeeds

    ticket, _ := s.Get(id)
    assert.Equal(t, StatusClosed, ticket.Status)
}

func TestDepTree(t *testing.T) {
    // Create: A depends on B, B depends on C
    out := runCmd(t, "dep", "tree", idA)
    autogold.ExpectFile(t, out)
}
```

Run `go test -update` to refresh golden files.

### Coverage Target

- 80%+ on `internal/ticket` and `internal/store`
- Integration coverage for all commands
- Edge cases: empty store, ambiguous IDs, circular deps

## Implementation Phases

### Phase 1: Core Foundation
1. Initialize module: `go mod init github.com/kostya/kt`
2. Add dependencies
3. Implement `internal/ticket/ticket.go` (types, parse, write)
4. Implement `internal/store/store.go` (CRUD, ID gen)
5. Unit tests for ticket + store

### Phase 2: Basic Commands
6. Cobra setup: `cmd/kt/main.go`, `internal/cmd/root.go`
7. Output mode detection (TTY/JSON)
8. Commands: `create`, `show`, `ls`
9. Commands: `start`, `close`, `reopen`, `status`, `pass`
10. Integration tests for basic flow

### Phase 3: Dependencies & Links
11. Commands: `dep add`, `dep rm`, `dep tree`
12. Commands: `link add`, `link rm`
13. Commands: `ready`, `blocked`
14. Integration tests for dep/link logic

### Phase 4: Remaining Commands
15. Commands: `closed`, `stats`, `query`
16. Commands: `edit`, `add-note`
17. Full integration test coverage

### Phase 5: Polish
18. Error messages and help text
19. README.md with usage docs
20. Final test pass, verify 80%+ coverage

## Differences from Original

| Aspect | Original (bash) | kt (Go) |
|--------|-----------------|---------|
| Language | Bash + awk | Go |
| `dep`/`undep` | Flat commands | `dep add`/`dep rm` subcommands |
| `link`/`unlink` | Flat commands | `link add`/`link rm` subcommands |
| Multi-ID | Single ID only | `start/close/reopen/pass/show` accept multiple |
| JSON output | `query` only | All commands via `--json` or pipe detection |
| Test validation | None | `tests_passed` field blocks close |
| Stats | None | `kt stats` command |
| Beads migration | Yes | Removed |
